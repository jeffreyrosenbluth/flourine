{-# LANGUAGE RankNTypes #-}

-------------------------------------------------------------------------------
-- |
-- Module      :  Fluorine.Component
-- Copyright   :  (c) 2015 Jeffrey Rosenbluth
-- License     :  BSD-style (see LICENSE)
-- Maintainer  :  jeffrey.rosenbluth@gmail.com
--
-- This module defines a type of composable _components_, built from
-- the types provided by this library - signal functions and HTML documents.
-------------------------------------------------------------------------------

module Fluorine.Component
  ( Component()
  , combine
  , hoistComponent
  ) where

import Fluorine.HTML   (HTML())
import Fluorine.Signal (SF1(), mergeWith)

-- | A component.
--
--   The type parameters are, in order:
--
--   - `m`, the monad used to track effects required by external requests
--   - `req`, the type of external requests
--   - `res`, the type of external responses
--
--   Request and response types are public, but the component may also use an _internal_ type
--   of messages, as illustrated by the type of the `component` function.
--
--   The main interface to Halogen is the `runUI` function, which takes a component as an argument,
--   with certain constraints between the type arguments. This module leaves the type arguments
--   unrestricted, allowing components to be composed in various ways.
--
--   If you do not use a particular feature (e.g. requests, responses, effects), you might like to leave
--   the corresponding type parameter unconstrained in the declaration of your component.

type Component m req res = SF1 req (HTML (m res))

-- | Map a natural transformation over the monad type argument of a `Component`.
--
-- | This function may be useful during testing, to mock requests with a different monad.
hoistComponent :: (forall a. m a -> n a) -> Component m req res -> Component n req res
hoistComponent f sf = (f <$>) <$> sf

-- | Combine two components into a single component.
--
--   The first argument is a function which combines the two rendered HTML documents into a single document.
--
--   This function works on request and response types by taking the _sum_ in each component. The left summand
--   gets dispatched to (resp. is generated by) the first component, and the right summand to the second component.
combine :: Functor m => (forall a. HTML a -> HTML a -> HTML a)
        -> Component m req1 res1
        -> Component m req2 res2
        -> Component m (Either req1 req2) (Either res1 res2)
combine f = mergeWith f1
  where
  f1 n1 n2 = f ((Left <$>) <$> n1) ((Right <$>) <$> n2)
